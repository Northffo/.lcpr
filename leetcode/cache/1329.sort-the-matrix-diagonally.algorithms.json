{"id":1253,"fid":"1329","name":"将矩阵按对角线排序","slug":"sort-the-matrix-diagonally","link":"https://leetcode.cn/problems/sort-the-matrix-diagonally/description/","percent":77.90704870350888,"level":"Medium","category":"algorithms","en_name":"Sort the Matrix Diagonally","cn_name":"将矩阵按对角线排序","totalAC":"21.5K","totalSubmit":"26.7K","likes":116,"dislikes":0,"desc":"<p><strong>矩阵对角线</strong> 是一条从矩阵最上面行或者最左侧列中的某个元素开始的对角线，沿右下方向一直到矩阵末尾的元素。例如，矩阵 <code>mat</code> 有 <code>6</code> 行 <code>3</code> 列，从 <code>mat[2][0]</code> 开始的 <strong>矩阵对角线</strong> 将会经过 <code>mat[2][0]</code>、<code>mat[3][1]</code> 和 <code>mat[4][2]</code> 。</p>\n\n<p>给你一个 <code>m * n</code> 的整数矩阵 <code>mat</code> ，请你将同一条 <strong>矩阵对角线 </strong>上的元素按升序排序后，返回排好序的矩阵。</p>\n\n<p> </p>\n\n<p><strong>示例 1：</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/25/1482_example_1_2.png\" style=\"height: 198px; width: 500px;\" /></p>\n\n<pre>\n<strong>输入：</strong>mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]\n<strong>输出：</strong>[[1,1,1,1],[1,2,2,2],[1,2,3,3]]\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]\n<strong>输出：</strong>[[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]\n</pre>\n\n<p> </p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 <= m, n <= 100</code></li>\n\t<li><code>1 <= mat[i][j] <= 100</code></li>\n</ul>\n","templates":[{"value":"cpp","text":"C++","defaultCode":"class Solution {\npublic:\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\n\n    }\n};"},{"value":"java","text":"Java","defaultCode":"class Solution {\n    public int[][] diagonalSort(int[][] mat) {\n\n    }\n}"},{"value":"python","text":"Python","defaultCode":"class Solution(object):\n    def diagonalSort(self, mat):\n        \"\"\"\n        :type mat: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\""},{"value":"python3","text":"Python3","defaultCode":"class Solution:\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:"},{"value":"c","text":"C","defaultCode":"/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** diagonalSort(int** mat, int matSize, int* matColSize, int* returnSize, int** returnColumnSizes) {\n    \n}"},{"value":"csharp","text":"C#","defaultCode":"public class Solution {\n    public int[][] DiagonalSort(int[][] mat) {\n\n    }\n}"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\n * @param {number[][]} mat\n * @return {number[][]}\n */\nvar diagonalSort = function(mat) {\n\n};"},{"value":"typescript","text":"TypeScript","defaultCode":"function diagonalSort(mat: number[][]): number[][] {\n    \n};"},{"value":"php","text":"PHP","defaultCode":"class Solution {\n\n    /**\n     * @param Integer[][] $mat\n     * @return Integer[][]\n     */\n    function diagonalSort($mat) {\n\n    }\n}"},{"value":"swift","text":"Swift","defaultCode":"class Solution {\n    func diagonalSort(_ mat: [[Int]]) -> [[Int]] {\n\n    }\n}"},{"value":"kotlin","text":"Kotlin","defaultCode":"class Solution {\n    fun diagonalSort(mat: Array<IntArray>): Array<IntArray> {\n\n    }\n}"},{"value":"dart","text":"Dart","defaultCode":"class Solution {\n  List<List<int>> diagonalSort(List<List<int>> mat) {\n    \n  }\n}"},{"value":"golang","text":"Go","defaultCode":"func diagonalSort(mat [][]int) [][]int {\n\n}"},{"value":"ruby","text":"Ruby","defaultCode":"# @param {Integer[][]} mat\n# @return {Integer[][]}\ndef diagonal_sort(mat)\n\nend"},{"value":"scala","text":"Scala","defaultCode":"object Solution {\n    def diagonalSort(mat: Array[Array[Int]]): Array[Array[Int]] = {\n\n    }\n}"},{"value":"rust","text":"Rust","defaultCode":"impl Solution {\n    pub fn diagonal_sort(mat: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n\n    }\n}"},{"value":"racket","text":"Racket","defaultCode":"(define/contract (diagonal-sort mat)\n  (-> (listof (listof exact-integer?)) (listof (listof exact-integer?)))\n  )"},{"value":"erlang","text":"Erlang","defaultCode":"-spec diagonal_sort(Mat :: [[integer()]]) -> [[integer()]].\ndiagonal_sort(Mat) ->\n  ."},{"value":"elixir","text":"Elixir","defaultCode":"defmodule Solution do\n  @spec diagonal_sort(mat :: [[integer]]) :: [[integer]]\n  def diagonal_sort(mat) do\n    \n  end\nend"}],"testcase":"[[3,3,1,1],[2,2,1,2],[1,1,1,2]]","testable":true,"templateMeta":{"name":"diagonalSort","params":[{"name":"mat","type":"integer[][]"}],"return":{"type":"integer[][]"}}}