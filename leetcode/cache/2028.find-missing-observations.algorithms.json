{"id":2155,"fid":"2028","name":"找出缺失的观测数据","slug":"find-missing-observations","link":"https://leetcode.cn/problems/find-missing-observations/description/","percent":50.76564675132816,"level":"Medium","category":"algorithms","en_name":"Find Missing Observations","cn_name":"找出缺失的观测数据","totalAC":"48.9K","totalSubmit":"93.2K","likes":92,"dislikes":0,"desc":"<p>现有一份 <code>n + m</code>&nbsp;次投掷单个<strong> 六面</strong> 骰子的观测数据，骰子的每个面从 <code>1</code> 到 <code>6</code> 编号。观测数据中缺失了 <code>n</code> 份，你手上只拿到剩余&nbsp;<code>m</code> 次投掷的数据。幸好你有之前计算过的这 <code>n + m</code> 次投掷数据的 <strong>平均值</strong> 。</p>\n\n<p>给你一个长度为 <code>m</code> 的整数数组 <code>rolls</code> ，其中&nbsp;<code>rolls[i]</code> 是第 <code>i</code> 次观测的值。同时给你两个整数 <code>mean</code> 和 <code>n</code> 。</p>\n\n<p>返回一个长度为<em> </em><code>n</code><em> </em>的数组，包含所有缺失的观测数据，且满足这<em> </em><code>n + m</code><em> </em>次投掷的 <strong>平均值</strong> 是<em> </em><code>mean</code> 。如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。</p>\n\n<p><code>k</code>&nbsp;个数字的 <strong>平均值</strong> 为这些数字求和后再除以&nbsp;<code>k</code> 。</p>\n\n<p>注意 <code>mean</code> 是一个整数，所以 <code>n + m</code> 次投掷的总和需要被&nbsp;<code>n + m</code>&nbsp;整除。</p>\n\n<p>&nbsp;</p>\n\n<p><strong>示例 1：</strong></p>\n\n<pre>\n<strong>输入：</strong>rolls = [3,2,4,3], mean = 4, n = 2\n<strong>输出：</strong>[6,6]\n<strong>解释：</strong>所有 n + m 次投掷的平均值是 (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4 。\n</pre>\n\n<p><strong>示例 2：</strong></p>\n\n<pre>\n<strong>输入：</strong>rolls = [1,5,6], mean = 3, n = 4\n<strong>输出：</strong>[2,3,2,2]\n<strong>解释：</strong>所有 n + m 次投掷的平均值是 (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3 。\n</pre>\n\n<p><strong>示例 3：</strong></p>\n\n<pre>\n<strong>输入：</strong>rolls = [1,2,3,4], mean = 6, n = 4\n<strong>输出：</strong>[]\n<strong>解释：</strong>无论丢失的 4 次数据是什么，平均值都不可能是 6 。\n</pre>\n\n<p><strong>示例 4：</strong></p>\n\n<pre>\n<strong>输入：</strong>rolls = [1], mean = 3, n = 1\n<strong>输出：</strong>[5]\n<strong>解释：</strong>所有 n + m 次投掷的平均值是 (1 + 5) / 2 = 3 。\n</pre>\n\n<p>&nbsp;</p>\n\n<p><strong>提示：</strong></p>\n\n<ul>\n\t<li><code>m == rolls.length</code></li>\n\t<li><code>1 &lt;= n, m &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= rolls[i], mean &lt;= 6</code></li>\n</ul>\n","templates":[{"value":"cpp","text":"C++","defaultCode":"class Solution {\npublic:\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\n        \n    }\n};"},{"value":"java","text":"Java","defaultCode":"class Solution {\n    public int[] missingRolls(int[] rolls, int mean, int n) {\n\n    }\n}"},{"value":"python","text":"Python","defaultCode":"class Solution(object):\n    def missingRolls(self, rolls, mean, n):\n        \"\"\"\n        :type rolls: List[int]\n        :type mean: int\n        :type n: int\n        :rtype: List[int]\n        \"\"\""},{"value":"python3","text":"Python3","defaultCode":"class Solution:\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:"},{"value":"c","text":"C","defaultCode":"/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* missingRolls(int* rolls, int rollsSize, int mean, int n, int* returnSize) {\n    \n}"},{"value":"csharp","text":"C#","defaultCode":"public class Solution {\n    public int[] MissingRolls(int[] rolls, int mean, int n) {\n\n    }\n}"},{"value":"javascript","text":"JavaScript","defaultCode":"/**\n * @param {number[]} rolls\n * @param {number} mean\n * @param {number} n\n * @return {number[]}\n */\nvar missingRolls = function(rolls, mean, n) {\n\n};"},{"value":"typescript","text":"TypeScript","defaultCode":"function missingRolls(rolls: number[], mean: number, n: number): number[] {\n    \n};"},{"value":"php","text":"PHP","defaultCode":"class Solution {\n\n    /**\n     * @param Integer[] $rolls\n     * @param Integer $mean\n     * @param Integer $n\n     * @return Integer[]\n     */\n    function missingRolls($rolls, $mean, $n) {\n\n    }\n}"},{"value":"swift","text":"Swift","defaultCode":"class Solution {\n    func missingRolls(_ rolls: [Int], _ mean: Int, _ n: Int) -> [Int] {\n\n    }\n}"},{"value":"kotlin","text":"Kotlin","defaultCode":"class Solution {\n    fun missingRolls(rolls: IntArray, mean: Int, n: Int): IntArray {\n\n    }\n}"},{"value":"dart","text":"Dart","defaultCode":"class Solution {\n  List<int> missingRolls(List<int> rolls, int mean, int n) {\n    \n  }\n}"},{"value":"golang","text":"Go","defaultCode":"func missingRolls(rolls []int, mean int, n int) []int {\n\n}"},{"value":"ruby","text":"Ruby","defaultCode":"# @param {Integer[]} rolls\n# @param {Integer} mean\n# @param {Integer} n\n# @return {Integer[]}\ndef missing_rolls(rolls, mean, n)\n\nend"},{"value":"scala","text":"Scala","defaultCode":"object Solution {\n    def missingRolls(rolls: Array[Int], mean: Int, n: Int): Array[Int] = {\n\n    }\n}"},{"value":"rust","text":"Rust","defaultCode":"impl Solution {\n    pub fn missing_rolls(rolls: Vec<i32>, mean: i32, n: i32) -> Vec<i32> {\n\n    }\n}"},{"value":"racket","text":"Racket","defaultCode":"(define/contract (missing-rolls rolls mean n)\n  (-> (listof exact-integer?) exact-integer? exact-integer? (listof exact-integer?))\n  )"},{"value":"erlang","text":"Erlang","defaultCode":"-spec missing_rolls(Rolls :: [integer()], Mean :: integer(), N :: integer()) -> [integer()].\nmissing_rolls(Rolls, Mean, N) ->\n  ."},{"value":"elixir","text":"Elixir","defaultCode":"defmodule Solution do\n  @spec missing_rolls(rolls :: [integer], mean :: integer, n :: integer) :: [integer]\n  def missing_rolls(rolls, mean, n) do\n    \n  end\nend"}],"testcase":"[3,2,4,3]\n4\n2","testable":true,"templateMeta":{"name":"missingRolls","params":[{"name":"rolls","type":"integer[]"},{"type":"integer","name":"mean"},{"type":"integer","name":"n"}],"return":{"type":"integer[]"}}}